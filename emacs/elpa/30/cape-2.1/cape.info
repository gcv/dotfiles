This is docpgt8f1.info, produced by makeinfo version 6.8 from cape.texi.

INFO-DIR-SECTION Emacs misc features
START-INFO-DIR-ENTRY
* Cape: (cape).         Completion At Point Extensions.
END-INFO-DIR-ENTRY


File: docpgt8f1.info,  Node: Top,  Next: Available Capfs,  Up: (dir)

cape.el - Let your completions fly!
***********************************

Cape provides Completion At Point Extensions which can be used in
combination with Corfu (https://github.com/minad/corfu), Company
(https://github.com/company-mode/company-mode) or the default completion
UI.  The completion backends used by â€˜completion-at-pointâ€™ are so called
â€˜completion-at-point-functionsâ€™ (Capfs).

   You can register the â€˜cape-*â€™ functions in the
â€˜completion-at-point-functionsâ€™ list.  This makes the backends available
for completion, which is usually invoked by pressing â€˜TABâ€™ or â€˜M-TABâ€™.
The functions can also be invoked interactively to trigger the
respective completion at point.  You can bind them directly to a key in
your user configuration.  Notable commands/Capfs are â€˜cape-lineâ€™ for
completion of a line from the current buffer, â€˜cape-historyâ€™ for history
completion in shell or Comint modes and â€˜cape-fileâ€™ for completion of
file names.  The commands â€˜cape-elisp-symbolâ€™ and â€˜cape-elisp-blockâ€™ are
useful for documentation of Elisp packages or configurations, since they
complete Elisp anywhere.

   Cape has the super power to transform Company backends into Capfs and
merge multiple Capfs into a Super-Capf!  These transformers allow you to
still take advantage of Company backends even if you are not using
Company as frontend.

* Menu:

* Available Capfs::
* Configuration::
* CAPF adapters and transformers::
* Contributions::

â€” The Detailed Node Listing â€”

CAPF adapters and transformers

* Company adapter::
* Super-Capf - Merging multiple Capfs::
* Capf-Buster - Cache busting::
* Capf transformers::



File: docpgt8f1.info,  Node: Available Capfs,  Next: Configuration,  Prev: Top,  Up: Top

1 Available Capfs
*****************

   â€¢ â€˜cape-abbrevâ€™: Complete abbreviation (â€˜add-global-abbrevâ€™,
     â€˜add-mode-abbrevâ€™).
   â€¢ â€˜cape-dabbrevâ€™: Complete word from current buffers.  See also
     â€˜dabbrev-capfâ€™ on Emacs 29.
   â€¢ â€˜cape-dictâ€™: Complete word from dictionary file.
   â€¢ â€˜cape-elisp-blockâ€™: Complete Elisp in Org or Markdown code block.
   â€¢ â€˜cape-elisp-symbolâ€™: Complete Elisp symbol.
   â€¢ â€˜cape-emojiâ€™: Complete Emoji.  Available on Emacs 29 and newer.
   â€¢ â€˜cape-fileâ€™: Complete file name.
   â€¢ â€˜cape-historyâ€™: Complete from Eshell, Comint or minibuffer history.
   â€¢ â€˜cape-keywordâ€™: Complete programming language keyword.
   â€¢ â€˜cape-lineâ€™: Complete entire line from current buffer.
   â€¢ â€˜cape-rfc1345â€™: Complete Unicode char using RFC 1345 mnemonics.
   â€¢ â€˜cape-sgmlâ€™: Complete Unicode char from SGML entity, e.g.,
     â€˜&alphaâ€™.
   â€¢ â€˜cape-texâ€™: Complete Unicode char from TeX command, e.g.  â€˜\hbarâ€™.


File: docpgt8f1.info,  Node: Configuration,  Next: CAPF adapters and transformers,  Prev: Available Capfs,  Up: Top

2 Configuration
***************

Cape is available on GNU ELPA and MELPA.  You can install the package
with â€˜package-installâ€™.  In the following we present a sample
configuration based on the popular â€˜use-packageâ€™ macro.

   I recommend to bind the â€˜cape-*â€™ completion commands to keys such
that you can invoke them explicitly.  This makes particular sense for
special Capfs which you only want to trigger in rare circumstances.  See
the â€˜:bindâ€™ specification below.

   Furthermore the â€˜cape-*â€™ functions are Capfs which you can add to the
â€˜completion-at-point-functionsâ€™ list.  Take care when adding Capfs to
the list since each of the Capfs adds a small runtime cost.  Note that
the Capfs which occur earlier in the list take precedence, such that the
first Capf returning a result will win and the later Capfs may not get a
chance to run.  In order to merge Capfs you can try the function
â€˜cape-capf-superâ€™.

   One must distinguish the buffer-local and the global value of the
â€˜completion-at-point-functionsâ€™ variable.  The buffer-local value of the
list takes precedence, but if the buffer-local list contains the symbol
â€˜tâ€™ at the end, it means that the functions specified in the global list
should be executed afterwards.  The special meaning of the value â€˜tâ€™ is
a feature of the â€˜run-hooksâ€™ function, see the section *note "Running
Hooks" in the Elisp manual: (elisp)Running Hooks. for further
information.

     ;; Enable Corfu completion UI
     ;; See the Corfu README for more configuration tips.
     (use-package corfu
       :init
       (global-corfu-mode))

     ;; Add extensions
     (use-package cape
       ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
       ;; Press C-c p ? to for help.
       :bind ("C-c p" . cape-prefix-map) ;; Alternative key: M-<tab>, M-p, M-+
       ;; Alternatively bind Cape commands individually.
       ;; :bind (("C-c p d" . cape-dabbrev)
       ;;        ("C-c p h" . cape-history)
       ;;        ("C-c p f" . cape-file)
       ;;        ...)
       :init
       ;; Add to the global default value of `completion-at-point-functions' which is
       ;; used by `completion-at-point'.  The order of the functions matters, the
       ;; first function returning a result wins.  Note that the list of buffer-local
       ;; completion functions takes precedence over the global list.
       (add-hook 'completion-at-point-functions #'cape-dabbrev)
       (add-hook 'completion-at-point-functions #'cape-file)
       (add-hook 'completion-at-point-functions #'cape-elisp-block)
       ;; (add-hook 'completion-at-point-functions #'cape-history)
       ;; ...
     )


File: docpgt8f1.info,  Node: CAPF adapters and transformers,  Next: Contributions,  Prev: Configuration,  Up: Top

3 CAPF adapters and transformers
********************************

* Menu:

* Company adapter::
* Super-Capf - Merging multiple Capfs::
* Capf-Buster - Cache busting::
* Capf transformers::


File: docpgt8f1.info,  Node: Company adapter,  Next: Super-Capf - Merging multiple Capfs,  Up: CAPF adapters and transformers

3.1 Company adapter
===================

_Wrap your Company backend in a Cape and turn it into a Capf!_

   Cape provides the adapter â€˜cape-company-to-capfâ€™ for Company
backends.  The adapter transforms Company backends to Capfs which are
understood by the built-in Emacs completion mechanism.  The function is
approximately the inverse of the â€˜company-capfâ€™ backend from Company.
The adapter can be used as follows:

     ;; Use Company backends as Capfs.
     (setq-local completion-at-point-functions
       (mapcar #'cape-company-to-capf
         (list #'company-files #'company-keywords #'company-dabbrev)))

   Note that the adapter does not require Company to be installed or
enabled.  Backends implementing the Company specification do not
necessarily have to depend on Company, however in practice most backends
do.  The following shows a small example completion backend, which can
be used with both â€˜completion-at-pointâ€™ (Corfu, default completion) and
Company.

     (defvar demo-alist
       '((":-D" . "ğŸ˜€")
         (";-)" . "ğŸ˜‰")
         (":-/" . "ğŸ˜•")
         (":-(" . "ğŸ™")
         (":-*" . "ğŸ˜™")))

     (defun demo-backend (action &optional arg &rest _)
       (pcase action
         ('prefix (and (memq (char-before) '(?: ?\;))
                       (cons (string (char-before)) t)))
         ('candidates (all-completions arg demo-alist))
         ('annotation (concat " " (cdr (assoc arg demo-alist))))
         ('post-completion
          (let ((str (buffer-substring (- (point) 3) (point))))
            (delete-region (- (point) 3) (point))
          (insert (cdr (assoc str demo-alist)))))))

     ;; Register demo backend with `completion-at-point'
     (setq completion-at-point-functions
           (list (cape-company-to-capf #'demo-backend)))

     ;; Register demo backend with Company.
     (setq company-backends '(demo-backend))

   It is possible to merge multiple Company backends and use them as a
single Capf using the â€˜company--multi-backend-adapterâ€™ function from
Company.  The adapter transforms multiple Company backends into a single
Company backend, which can then be used as a Capf via
â€˜cape-company-to-capfâ€™.  Capfs can be merged directly with
â€˜cape-capf-superâ€™.

     (require 'company)
     ;; Use the company-dabbrev and company-elisp backends together.
     (setq completion-at-point-functions
           (list
            (cape-company-to-capf
             (apply-partially #'company--multi-backend-adapter
                              '(company-dabbrev company-elisp)))))


File: docpgt8f1.info,  Node: Super-Capf - Merging multiple Capfs,  Next: Capf-Buster - Cache busting,  Prev: Company adapter,  Up: CAPF adapters and transformers

3.2 Super-Capf - Merging multiple Capfs
=======================================

_Throw multiple Capfs under the Cape and get a Super-Capf!_

   Cape supports merging multiple Capfs using the function
â€˜cape-capf-superâ€™.  Due to some technical details, not all Capfs can be
merged successfully.  Merge Capfs one by one and make sure that you get
the desired outcome.

   Note that â€˜cape-capf-superâ€™ is not needed if multiple Capfs should
betried one after the other, for example you can use â€˜cape-fileâ€™
together with programming mode Capfs by adding â€˜cape-fileâ€™ to the
â€˜completion-at-point-functionsâ€™ list.  File completion will then be
available in comments and string literals, but not in normal code.
â€˜cape-capf-superâ€™ is only necessary if you want to combine multiple
Capfs, such that the candidates from multiple sources appear _together_
in the completion list at the same time.

   Capf merging requires completion functions which are sufficiently
well-behaved and completion functions which do not define completion
boundaries.  â€˜cape-capf-superâ€™ has the same restrictions as
â€˜completion-table-mergeâ€™ and â€˜completion-table-in-turnâ€™.  As a simple
rule of thumb, â€˜cape-capf-superâ€™ works for static completion functions
like â€˜cape-dabbrevâ€™, â€˜cape-keywordâ€™, â€˜cape-dictâ€™, etc., but not for
multi-step completions like â€˜cape-fileâ€™.

     ;; Merge the dabbrev, dict and keyword capfs, display candidates together.
     (setq-local completion-at-point-functions
                 (list (cape-capf-super #'cape-dabbrev #'cape-dict #'cape-keyword)))

     ;; Alternative: Define named Capf instead of using the anonymous Capf directly
     (defun cape-dabbrev-dict-keyword ()
       (cape-wrap-super #'cape-dabbrev #'cape-dict #'cape-keyword))
     (setq-local completion-at-point-functions (list #'cape-dabbrev-dict-keyword))

   See also the aforementioned â€˜company--multi-backend-adapterâ€™ from
Company, which allows you to merge multiple Company backends.


File: docpgt8f1.info,  Node: Capf-Buster - Cache busting,  Next: Capf transformers,  Prev: Super-Capf - Merging multiple Capfs,  Up: CAPF adapters and transformers

3.3 Capf-Buster - Cache busting
===============================

_The Capf-Buster ensures that you always get a fresh set of candidates!_

   If a Capf caches the candidates for too long we can use a cache
busting Capf-transformer.  For example the Capf merging function
â€˜cape-capf-superâ€™ creates a Capf, which caches the candidates for the
whole lifetime of the Capf.  Therefore you may want to combine a merged
Capf with a cache buster under some circumstances.  It is noteworthy
that the â€˜company-capfâ€™ backend from Company refreshes the completion
table frequently.  With the â€˜cape-capf-busterâ€™ we can achieve a
similarly refreshing strategy.

     (setq-local completion-at-point-functions
                 (list (cape-capf-buster #'some-caching-capf)))


File: docpgt8f1.info,  Node: Capf transformers,  Prev: Capf-Buster - Cache busting,  Up: CAPF adapters and transformers

3.4 Capf transformers
=====================

Cape provides a set of additional Capf transformation functions, which
are mostly meant to used by experts to fine tune the Capf behavior and
Capf interaction.  These can either be used as advices (â€˜cape-wrap-*)â€™
or to create a new Capf from an existing Capf (â€˜cape-capf-*â€™).  You can
bind the Capfs created by the Capf transformers with â€˜defaliasâ€™ to a
function symbol.

   â€¢ â€˜cape-capf-accept-allâ€™, â€˜cape-wrap-accept-allâ€™: Create a Capf which
     accepts every input as valid.
   â€¢ â€˜cape-capf-case-foldâ€™, â€˜cape-wrap-case-foldâ€™: Create a Capf which
     is case insensitive.
   â€¢ â€˜cape-capf-debugâ€™, â€˜cape-wrap-debugâ€™: Create a Capf which prints
     debugging messages.
   â€¢ â€˜cape-capf-inside-codeâ€™, â€˜cape-wrap-inside-codeâ€™: Ensure that Capf
     triggers only inside code.
   â€¢ â€˜cape-capf-inside-commentâ€™, â€˜cape-wrap-inside-commentâ€™: Ensure that
     Capf triggers only inside comments.
   â€¢ â€˜cape-capf-inside-facesâ€™, â€˜cape-wrap-inside-facesâ€™: Ensure that
     Capf triggers only inside text with certain faces.
   â€¢ â€˜cape-capf-inside-stringâ€™, â€˜cape-wrap-inside-stringâ€™: Ensure that
     Capf triggers only inside a string literal.
   â€¢ â€˜cape-capf-interactiveâ€™, â€˜cape-interactiveâ€™: Create a Capf which
     can be called interactively.
   â€¢ â€˜cape-capf-nonexclusiveâ€™, â€˜cape-wrap-nonexclusiveâ€™: Mark Capf as
     non-exclusive.
   â€¢ â€˜cape-capf-noninterruptibleâ€™, â€˜cape-wrap-noninterruptibleâ€™: Protect
     a Capf which does not like to be interrupted.
   â€¢ â€˜cape-capf-passthroughâ€™, â€˜cape-wrap-passthroughâ€™: Defeat entire
     completion style filtering.
   â€¢ â€˜cape-capf-predicateâ€™, â€˜cape-wrap-predicateâ€™: Add candidate
     predicate to a Capf.
   â€¢ â€˜cape-capf-prefix-lengthâ€™, â€˜cape-wrap-prefix-lengthâ€™: Enforce a
     minimal prefix length.
   â€¢ â€˜cape-capf-propertiesâ€™, â€˜cape-wrap-propertiesâ€™: Add completion
     properties to a Capf.
   â€¢ â€˜cape-capf-purifyâ€™, â€˜cape-wrap-purifyâ€™: Purify a broken Capf and
     ensure that it does not modify the buffer.
   â€¢ â€˜cape-capf-silentâ€™, â€˜cape-wrap-silentâ€™: Silence Capf messages and
     errors.
   â€¢ â€˜cape-capf-sortâ€™, â€˜cape-wrap-sortâ€™: Add sort function to a Capf.
   â€¢ â€˜cape-capf-superâ€™, â€˜cape-wrap-superâ€™: Merge multiple Capfs into a
     Super-Capf.

   In the following we show a few example configurations, which have
come up on the Cape (https://github.com/minad/cape/issues) or Corfu
issue tracker (https://github.com/minad/corfu/issues) or the Corfu wiki.
(https://github.com/minad/corfu/wiki) I use some of these tweaks in my
personal configuration.

     ;; Example 1: Sanitize the `pcomplete-completions-at-point' Capf.  The Capf has
     ;; undesired side effects on Emacs 28.  These advices are not needed on Emacs 29
     ;; and newer.
     (when (< emacs-major-version 29)
       (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
       (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))

     ;; Example 2: Configure a Capf with a specific auto completion prefix length
     (setq-local completion-at-point-functions
                 (list (cape-capf-prefix-length #'cape-dabbrev 2)))

     ;; Example 3: Create a Capf with debugging messages
     (setq-local completion-at-point-functions (list (cape-capf-debug #'cape-dict)))

     ;; Example 4: Named Capf
     (defalias 'cape-dabbrev-min-2 (cape-capf-prefix-length #'cape-dabbrev 2))
     (setq-local completion-at-point-functions (list #'cape-dabbrev-min-2))

     ;; Example 5: Define a defensive Dabbrev Capf, which accepts all inputs.  If you
     ;; use Corfu and `corfu-auto=t', the first candidate won't be auto selected if
     ;; `corfu-preselect=valid', such that it cannot be accidentally committed when
     ;; pressing RET.
     (defun my-cape-dabbrev-accept-all ()
       (cape-wrap-accept-all #'cape-dabbrev))
     (add-hook 'completion-at-point-functions #'my-cape-dabbrev-accept-all)

     ;; Example 6: Define interactive Capf which can be bound to a key.  Here we wrap
     ;; the `elisp-completion-at-point' such that we can complete Elisp code
     ;; explicitly in arbitrary buffers.
     (keymap-global-set "C-c p e" (cape-capf-interactive #'elisp-completion-at-point))

     ;; Example 7: Ignore :keywords in Elisp completion.
     (defun ignore-elisp-keywords (sym)
       (not (keywordp sym)))
     (setq-local completion-at-point-functions
                 (list (cape-capf-predicate #'elisp-completion-at-point
                                            #'ignore-elisp-keywords)))


File: docpgt8f1.info,  Node: Contributions,  Prev: CAPF adapters and transformers,  Up: Top

4 Contributions
***************

Since this package is part of GNU ELPA
(https://elpa.gnu.org/packages/cape.html) contributions require a
copyright assignment to the FSF.



Tag Table:
Node: Top208
Node: Available Capfs1948
Node: Configuration3059
Node: CAPF adapters and transformers5867
Node: Company adapter6175
Node: Super-Capf - Merging multiple Capfs8870
Node: Capf-Buster - Cache busting11051
Node: Capf transformers11990
Node: Contributions16820

End Tag Table


Local Variables:
coding: utf-8
End:
